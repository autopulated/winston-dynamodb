// Generated by CoffeeScript 1.6.2
(function() {
  var AWS, DynamoDB, formatDate, formatTimestamp, hostname, microtime, mostRecentMonday, util, uuidV4, winston, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  winston = require("winston");

  util = require("util");

  AWS = require("aws-sdk");

  uuidV4 = require("node-uuid").v4;

  _ = require("lodash");

  hostname = require("os").hostname();

  microtime = require('microtime');

  formatTimestamp = function(musecs) {
    var date, key, keys, _i, _len;

    date = new Date(musecs / 1000);
    date = {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      day: date.getDate(),
      hour: date.getHours(),
      minute: date.getMinutes(),
      second: date.getSeconds(),
      musecs: musecs % 1000000
    };
    keys = _.without(Object.keys(date, "year", "month", "day"));
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      if (date[key] < 10) {
        date[key] = "0" + date[key];
      }
    }
    while (date.musecs.toString().length < 6) {
      date.musecs = "0" + date.musecs;
    }
    return "" + date.year + "-" + date.month + "-" + date.day + " " + date.hour + ":" + date.minute + ":" + date.second + "." + date.musecs;
  };

  formatDate = function(date) {
    var key, keys, _i, _len;

    date = {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      day: date.getDate()
    };
    keys = _.without(Object.keys(date, "year", "month", "day"));
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      if (date[key] < 10) {
        date[key] = "0" + date[key];
      }
    }
    return "" + date.year + "." + date.month + "." + date.day;
  };

  DynamoDB = exports.DynamoDB = function(options) {
    var regions, _ref;

    if (options == null) {
      options = {};
    }
    regions = ["us-east-1", "us-west-1", "us-west-2", "eu-west-1", "ap-northeast-1", "ap-southeast-1", "ap-southeast-2", "sa-east-1"];
    if (options.accessKeyId == null) {
      throw new Error("need accessKeyId");
    }
    if (options.secretAccessKey == null) {
      throw new Error("need secretAccessKey");
    }
    if (options.region == null) {
      throw new Error("need region");
    }
    if (_ref = options.region, __indexOf.call(regions, _ref) < 0) {
      throw new Error("unavailable region given");
    }
    if (options.tableName == null) {
      throw new Error("need tableName");
    }
    AWS.config.update({
      accessKeyId: options.accessKeyId,
      secretAccessKey: options.secretAccessKey,
      region: options.region
    });
    if ('hostname' in options) {
      hostname = options.hostname;
    }
    this.name = "dynamodb";
    this.level = options.level || "info";
    this.db = new AWS.DynamoDB();
    this.region = options.region;
    this.tableName = options.tableName;
    if (options.provisionReadCapacity != null) {
      this.provisionReadCapacity = options.provisionReadCapacity;
    } else {
      this.provisionReadCapacity = 1;
    }
    if (options.provisionWriteCapacity != null) {
      this.provisionWriteCapacity = options.provisionWriteCapacity;
    } else {
      this.provisionWriteCapacity = 1;
    }
    this.ensureTables();
    setInterval(this.ensureTables.bind(this), (5 + 2 * Math.random()) * 60 * 60 * 1000);
  };

  util.inherits(DynamoDB, winston.Transport);

  DynamoDB.prototype.log = function(level, msg, meta, callback) {
    var params, use_hostname,
      _this = this;

    if ('hostname' in meta) {
      use_hostname = meta.hostname;
    } else {
      use_hostname = hostname;
    }
    params = {
      TableName: this.tableName + '.' + formatDate(mostRecentMonday(new Date())),
      Item: {
        level: {
          "S": level
        },
        timestamp: {
          "S": formatTimestamp(microtime.now())
        },
        msg: {
          "S": msg
        },
        hostname: {
          "S": use_hostname
        }
      }
    };
    if (meta != null) {
      params.Item.meta = {
        "S": JSON.stringify(meta)
      };
    }
    this.db.client.putItem(params, function(err, data) {
      if (err) {
        Error.captureStackTrace(err);
        return _this.emit("error", err);
      } else {
        return _this.emit("logged");
      }
    });
    return callback(null, true);
  };

  mostRecentMonday = function(today) {
    var diffToMonday;

    diffToMonday = 1 - today.getDay();
    if (diffToMonday > 0) {
      diffToMonday -= 7;
    }
    return new Date(today.getTime() + diffToMonday * 1000 * 60 * 60 * 24);
  };

  DynamoDB.prototype.ensureTables = function() {
    var addFoundTables, checkFoundTables, downgrade_tables, found_tables, last_week_table, monday, next_week_table, require_tables, this_week_table, today,
      _this = this;

    today = new Date();
    monday = mostRecentMonday(today);
    require_tables = [];
    downgrade_tables = [];
    this_week_table = this.tableName + '.' + formatDate(monday);
    require_tables.push(this_week_table);
    if (today - monday < 12 * 60 * 60 * 1000) {
      next_week_table = this.tableName + '.' + formatDate(new Date(monday.getTime() + 1000 * 60 * 60 * 24 * 7));
      require_tables.push(next_week_table);
    }
    if (today - monday > 12 * 60 * 60 * 1000) {
      last_week_table = this.tableName + '.' + formatDate(new Date(monday.getTime() - 1000 * 60 * 60 * 24 * 7));
      downgrade_tables.push(last_week_table);
    }
    found_tables = [];
    checkFoundTables = function() {
      var onTableActive, tn, _i, _j, _len, _len1;

      for (_i = 0, _len = downgrade_tables.length; _i < _len; _i++) {
        tn = downgrade_tables[_i];
        if (__indexOf.call(found_tables, tn) >= 0) {
          _this.downgradeTable(tn);
        }
      }
      for (_j = 0, _len1 = require_tables.length; _j < _len1; _j++) {
        tn = require_tables[_j];
        if (!(__indexOf.call(found_tables, tn) >= 0)) {
          _this.createTable(tn);
          onTableActive = function(err) {
            if (err) {
              _this.emit("error", err);
              setTimeout(_this.ensureTables.bind(_this), 15 * 60 * 1000);
            }
            return _this.ensureTables();
          };
          return _this.waitForTable(tn, onTableActive);
        }
      }
    };
    addFoundTables = function(err, data) {
      if (err) {
        return _this.emit("error", err);
      }
      found_tables = found_tables.concat(data.TableNames);
      if ('LastEvaluatedTableName' in data) {
        return _this.db.client.listTables({
          ExclusiveStartTableName: data.LastEvaluatedTableName
        }, addFoundTables);
      } else {
        return checkFoundTables();
      }
    };
    return this.db.client.listTables({}, addFoundTables);
  };

  DynamoDB.prototype.downgradeTable = function(tableName) {
    var set_rcap, set_wcap,
      _this = this;

    set_rcap = 1;
    set_wcap = 1;
    return this.db.client.describeTable({
      TableName: tableName
    }, function(err, data) {
      var params;

      if (err) {
        Error.captureStackTrace(err);
        return _this.emit("error", err);
      }
      if (data.Table.TableStatus === 'ACTIVE' && (data.Table.ProvisionedThroughput.ReadCapacityUnits !== set_rcap || data.Table.ProvisionedThroughput.WriteCapacityUnits !== set_wcap)) {
        params = {
          TableName: tableName,
          ProvisionedThroughput: {
            ReadCapacityUnits: set_rcap,
            WriteCapacityUnits: set_wcap
          }
        };
        return _this.db.client.updateTable(params, function(err, data) {
          if (err) {
            Error.captureStackTrace(err);
            return _this.emit("error", err);
          }
        });
      }
    });
  };

  DynamoDB.prototype.createTable = function(tableName) {
    var table_params,
      _this = this;

    table_params = {
      TableName: tableName,
      AttributeDefinitions: [
        {
          AttributeName: 'hostname',
          AttributeType: 'S'
        }, {
          AttributeName: 'timestamp',
          AttributeType: 'S'
        }, {
          AttributeName: 'level',
          AttributeType: 'S'
        }
      ],
      KeySchema: [
        {
          AttributeName: 'hostname',
          KeyType: 'HASH'
        }, {
          AttributeName: 'timestamp',
          KeyType: 'RANGE'
        }
      ],
      LocalSecondaryIndexes: [
        {
          IndexName: 'level-index',
          KeySchema: [
            {
              AttributeName: 'hostname',
              KeyType: 'HASH'
            }, {
              AttributeName: 'level',
              KeyType: 'RANGE'
            }
          ],
          Projection: {
            ProjectionType: 'KEYS_ONLY'
          }
        }
      ],
      ProvisionedThroughput: {
        ReadCapacityUnits: this.provisionReadCapacity,
        WriteCapacityUnits: this.provisionWriteCapacity
      }
    };
    return this.db.client.createTable(table_params, function(err, data) {
      if (err) {
        Error.captureStackTrace(err);
        return _this.emit("error", err);
      }
    });
  };

  DynamoDB.prototype.waitForTable = function(tableName, callback) {
    var _this = this;

    return this.db.client.describeTable({
      TableName: tableName
    }, function(err, data) {
      var onTimeout;

      if (err) {
        Error.captureStackTrace(err);
        return callback(err);
      }
      if (data.Table.TableStatus === "CREATING") {
        onTimeout = function() {
          return _this.waitForTable(tableName, callback);
        };
        return setTimeout(onTimeout, 60 * 1000);
      } else if (data.Table.TableStatus === "ACTIVE") {
        return callback(null);
      } else {
        return callback(new Error("wait for table state:" + data.Table.TableStatus));
      }
    });
  };

  winston.transports.DynamoDB = DynamoDB;

}).call(this);
